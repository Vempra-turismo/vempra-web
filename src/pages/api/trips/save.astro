---
import db from '../../../lib/turso';
import { v2 as cloudinary } from 'cloudinary';
import { Buffer } from 'node:buffer';

cloudinary.config({
    cloud_name: import.meta.env.CLOUDINARY_CLOUD_NAME,
    api_key: import.meta.env.CLOUDINARY_API_KEY,
    api_secret: import.meta.env.CLOUDINARY_API_SECRET,
    secure: true,
});

// Proteger el endpoint
if (!Astro.cookies.has('session')) {
  return new Response("No autorizado", { status: 401 });
}

if (Astro.request.method !== 'POST') {
    return new Response('MÃ©todo no permitido', { status: 405 });
}

const formData = await Astro.request.formData();
const id = formData.get('id')?.toString();
const isNew = !id;

// --- Manejo de la subida de imagen ---
const imageFile = formData.get('imageFile') as File;
let imageUrl = formData.get('imageUrl')?.toString(); // URL existente al editar

if (imageFile && imageFile.size > 0) {
    try {
        const arrayBuffer = await imageFile.arrayBuffer();
        const buffer = Buffer.from(arrayBuffer);

        const uploadResult: any = await new Promise((resolve, reject) => {
            const uploadStream = cloudinary.uploader.upload_stream(
                {
                    folder: 'vempra_viajes', // Opcional: organizar en una carpeta
                },
                (error, result) => {
                    if (result) {
                        resolve(result);
                    } else {
                        reject(error);
                    }
                }
            );
            uploadStream.end(buffer);
        });

        imageUrl = uploadResult.secure_url;
    } catch (e) {
        console.error("Error al subir la imagen a Cloudinary:", e);
        return new Response("Error al subir la imagen: " + (e as Error).message, { status: 500 });
    }
}

const tripData = {
    title: formData.get('title')?.toString(),
    url: formData.get('url')?.toString(),
    slogan: formData.get('slogan')?.toString() || null,
    price: formData.get('price')?.toString(),
    days: formData.get('days')?.toString(),
    imageUrl: imageUrl, // Usar la URL (nueva o existente)
    locality_id: formData.get('locality_id')?.toString(),
    departure_id: formData.get('departure_id')?.toString(),
    travel_type: formData.get('travel_type')?.toString(),
    season_name: formData.get('season_name')?.toString() || null,
    season_year: formData.get('season_year') ? parseInt(formData.get('season_year').toString()) : null,
};

// Obtener las etiquetas seleccionadas del formulario
const selectedTagNames = formData.getAll('tags').map(tag => tag.toString());

try {
    let tripId = id;

    if (isNew) {
        // --- Crear un nuevo viaje ---
        const result = await db.execute({
            sql: `
                INSERT INTO trips (title, url, slogan, price, days, imageUrl, locality_id, departure_id, travel_type, season_name, season_year)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                RETURNING id;
            `,
            args: Object.values(tripData)
        });
        tripId = result.rows[0].id.toString();
    } else {
        // --- Actualizar un viaje existente ---
        await db.execute({
            sql: `
                UPDATE trips SET
                    title = ?, url = ?, slogan = ?, price = ?, days = ?, imageUrl = ?,
                    locality_id = ?, departure_id = ?, travel_type = ?, season_name = ?,
                    season_year = ?
                WHERE id = ?
            `,
            args: [...Object.values(tripData), tripId]
        });
    }

    // --- Manejar Etiquetas ---
    const { rows: allTags } = await db.execute("SELECT id, name FROM tags");
    const selectedTagIds = allTags
        .filter((tag: any) => selectedTagNames.includes(tag.name))
        .map((tag: any) => tag.id);

    const batchStatements = [
        { sql: "DELETE FROM trip_tags WHERE trip_id = ?", args: [tripId] }
    ];

    for (const tagId of selectedTagIds) {
        batchStatements.push({ sql: "INSERT INTO trip_tags (trip_id, tag_id) VALUES (?, ?)", args: [tripId, tagId] });
    }

    if (batchStatements.length > 1) { // Solo ejecutar si hay etiquetas para procesar
        await db.batch(batchStatements, 'write');
    }

    return Astro.redirect('/admin/viajes?success=true');

} catch (e) {
    console.error(e);
    const errorMessage = encodeURIComponent((e as Error).message);
    return Astro.redirect(`/admin/viajes?success=false&error=${errorMessage}`);
}
---